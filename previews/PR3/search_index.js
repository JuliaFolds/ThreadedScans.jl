var documenterSearchIndex = {"docs":
[{"location":"#ThreadedScans.jl","page":"ThreadedScans.jl","title":"ThreadedScans.jl","text":"","category":"section"},{"location":"","page":"ThreadedScans.jl","title":"ThreadedScans.jl","text":"ThreadedScans","category":"page"},{"location":"#ThreadedScans","page":"ThreadedScans.jl","title":"ThreadedScans","text":"ThreadedScans: parallel scan implementations\n\n(Image: Dev)\n\nThreadedScans.jl provides threading-based parallel scan implementations for Julia.  The main high-level API is ThreadedScans.scan!(op, xs).\n\n\n\n\n\n","category":"module"},{"location":"#High-level-API","page":"ThreadedScans.jl","title":"High-level API","text":"","category":"section"},{"location":"","page":"ThreadedScans.jl","title":"ThreadedScans.jl","text":"ThreadedScans.scan!","category":"page"},{"location":"#ThreadedScans.scan!","page":"ThreadedScans.jl","title":"ThreadedScans.scan!","text":"ThreadedScans.scan!(op, xs::AbstractVector; [basesize]) -> xs\n\nCompute inclusive scan of a vector xs with an associative binary function op in parallel.\n\n\n\n\n\n","category":"function"},{"location":"#Low-level-API","page":"ThreadedScans.jl","title":"Low-level API","text":"","category":"section"},{"location":"","page":"ThreadedScans.jl","title":"ThreadedScans.jl","text":"ThreadedScans.partitioned_hillis_steele!\nThreadedScans.dac!\nThreadedScans.linear!","category":"page"},{"location":"#ThreadedScans.partitioned_hillis_steele!","page":"ThreadedScans.jl","title":"ThreadedScans.partitioned_hillis_steele!","text":"ThreadedScans.partitioned_hillis_steele!(op, xs::AbstractVector) -> xs\n\nCompute inclusive scan.  Intermediate reductions for ntasks chunks are computed in parallel and then merged using prefix sum algorithm by Hillis and Steele.  It is marginally better than other methods especially when the number of worker threads is large.\n\nKeyword arguments\n\nntasks = Threads.nthreads(): number of tasks\n\n\n\n\n\n","category":"function"},{"location":"#ThreadedScans.dac!","page":"ThreadedScans.jl","title":"ThreadedScans.dac!","text":"ThreadedScans.dac!(op, xs::AbstractVector) -> xs\n\nCompute inclusive scan. Use a divide-and-conquer strategy for spawning the tasks.  Intermediate reductions are propagated sequentially.  It is slightly better than ThreadedScans.linear!.\n\nKeyword arguments\n\nntasks = Threads.nthreads(): number of tasks\n\n\n\n\n\n","category":"function"},{"location":"#ThreadedScans.linear!","page":"ThreadedScans.jl","title":"ThreadedScans.linear!","text":"ThreadedScans.linear!(op, xs::AbstractVector) -> xs\n\nCompute inclusive scan. Spawn, wait, and propagation of intermediate reductions are all done sequentially.\n\nKeyword arguments\n\nntasks = Threads.nthreads(): number of tasks\n\n\n\n\n\n","category":"function"}]
}
